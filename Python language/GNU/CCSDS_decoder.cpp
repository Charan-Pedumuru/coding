#ifndef INCLUDED_FEC_DECODE_CCSDS_27_FB_IMPL_H
#define INCLUDED_FEC_DECODE_CCSDS_27_FB_IMPL_H
#ifdef HAVE_CONFIG_H
//#include "config.h"
#endif

#include <gnuradio/fec/viterbi.h>
#define POLYA 0x6d
#define POLYB 0x4f
#define BUTTERFLY(i, sym)                                         \
    {                                                             \
        int m0, m1;                                               \
                                                                  \
        /* ACS for 0 branch */                                    \
        m0 = state[i].metric + mets[sym];          /* 2*i */      \
        m1 = state[i + 32].metric + mets[3 ^ sym]; /* 2*i + 64 */ \
        if (m0 > m1) {                                            \
            next[2 * i].metric = m0;                              \
            next[2 * i].path = state[i].path << 1;                \
        } else {                                                  \
            next[2 * i].metric = m1;                              \
            next[2 * i].path = (state[i + 32].path << 1) | 1;     \
        }                                                         \
        /* ACS for 1 branch */                                    \
        m0 = state[i].metric + mets[3 ^ sym];  /* 2*i + 1 */      \
        m1 = state[i + 32].metric + mets[sym]; /* 2*i + 65 */     \
        if (m0 > m1) {                                            \
            next[2 * i + 1].metric = m0;                          \
            next[2 * i + 1].path = state[i].path << 1;            \
        } else {                                                  \
            next[2 * i + 1].metric = m1;                          \
            next[2 * i + 1].path = (state[i + 32].path << 1) | 1; \
        }                                                         \
    }

extern unsigned char Partab[]; /* Parity lookup table */

namespace gr {
namespace fec {

/* Convolutionally encode data into binary symbols */
unsigned char encode(unsigned char* symbols,
                     unsigned char* data,
                     unsigned int nbytes,
                     unsigned char encstate)
{
    int i;

    while (nbytes-- != 0) {
        for (i = 7; i >= 0; i--) {
            encstate = (encstate << 1) | ((*data >> i) & 1);
            *symbols++ = Partab[encstate & POLYA];
            *symbols++ = Partab[encstate & POLYB];
        }
        data++;
    }

    return encstate;
}

/* Viterbi decoder */
int viterbi(unsigned long* metric,  /* Final path metric (returned value) */
            unsigned char* data,    /* Decoded output data */
            unsigned char* symbols, /* Raw deinterleaved input symbols */
            unsigned int nbits,     /* Number of output bits */
            int mettab[2][256]      /* Metric table, [sent sym][rx symbol] */
)
{
    unsigned int bitcnt = 0;
    int mets[4];
    long bestmetric;
    int beststate, i;
    struct viterbi_state state0[64], state1[64], *state, *next;

    state = state0;
    next = state1;

    /* Initialize starting metrics to prefer 0 state */
    state[0].metric = 0;
    for (i = 1; i < 64; i++)
        state[i].metric = -999999;
    state[0].path = 0;

    for (bitcnt = 0; bitcnt < nbits; bitcnt++) {
        /* Read input symbol pair and compute all possible branch
         * metrics
         */
        mets[0] = mettab[0][symbols[0]] + mettab[0][symbols[1]];
        mets[1] = mettab[0][symbols[0]] + mettab[1][symbols[1]];
        mets[2] = mettab[1][symbols[0]] + mettab[0][symbols[1]];
        mets[3] = mettab[1][symbols[0]] + mettab[1][symbols[1]];
        symbols += 2;

        /* These macro calls were generated by genbut.c */
        BUTTERFLY(0, 0);
        BUTTERFLY(1, 1);
        BUTTERFLY(2, 3);
        BUTTERFLY(3, 2);
        BUTTERFLY(4, 3);
        BUTTERFLY(5, 2);
        BUTTERFLY(6, 0);
        BUTTERFLY(7, 1);
        BUTTERFLY(8, 0);
        BUTTERFLY(9, 1);
        BUTTERFLY(10, 3);
        BUTTERFLY(11, 2);
        BUTTERFLY(12, 3);
        BUTTERFLY(13, 2);
        BUTTERFLY(14, 0);
        BUTTERFLY(15, 1);
        BUTTERFLY(16, 2);
        BUTTERFLY(17, 3);
        BUTTERFLY(18, 1);
        BUTTERFLY(19, 0);
        BUTTERFLY(20, 1);
        BUTTERFLY(21, 0);
        BUTTERFLY(22, 2);
        BUTTERFLY(23, 3);
        BUTTERFLY(24, 2);
        BUTTERFLY(25, 3);
        BUTTERFLY(26, 1);
        BUTTERFLY(27, 0);
        BUTTERFLY(28, 1);
        BUTTERFLY(29, 0);
        BUTTERFLY(30, 2);
        BUTTERFLY(31, 3);

        /* Swap current and next states */
        if (bitcnt & 1) {
            state = state0;
            next = state1;
        } else {
            state = state1;
            next = state0;
        }
        // ETTUS
        // if(bitcnt > nbits-7){
        /* In tail, poison non-zero nodes */
        // for(i=1;i<64;i += 2)
        //	state[i].metric = -9999999;
        //}
        /* Produce output every 8 bits once path memory is full */
        if ((bitcnt % 8) == 5 && bitcnt > 32) {
            /* Find current best path */
            bestmetric = state[0].metric;
            beststate = 0;
            for (i = 1; i < 64; i++) {
                if (state[i].metric > bestmetric) {
                    bestmetric = state[i].metric;
                    beststate = i;
                }
            }
#ifdef notdef
            printf("metrics[%d] = %d state = %lx\n",
                   beststate,
                   state[beststate].metric,
                   state[beststate].path);
#endif
            *data++ = state[beststate].path >> 24;
        }
    }
    /* Output remaining bits from 0 state */
    // ETTUS  Find best state instead
    bestmetric = state[0].metric;
    beststate = 0;
    for (i = 1; i < 64; i++) {
        if (state[i].metric > bestmetric) {
            bestmetric = state[i].metric;
            beststate = i;
        }
    }
    if ((i = bitcnt % 8) != 6)
        state[beststate].path <<= 6 - i;

    *data++ = state[beststate].path >> 24;
    *data++ = state[beststate].path >> 16;
    *data++ = state[beststate].path >> 8;
    *data = state[beststate].path;
    // printf ("BS = %d\tBSM = %d\tM0 =
    // %d\n",beststate,state[beststate].metric,state[0].metric);
    *metric = state[beststate].metric;
    return 0;
}


void viterbi_chunks_init(struct viterbi_state* state)
{
    // Initialize starting metrics to prefer 0 state
    int i;
    state[0].metric = 0;
    state[0].path = 0;
    for (i = 1; i < 64; i++)
        state[i].metric = -999999;
}

void viterbi_butterfly8(unsigned char* symbols,
                        int mettab[2][256],
                        struct viterbi_state* state0,
                        struct viterbi_state* state1)
{
    unsigned int bitcnt;
    int mets[4];

    struct viterbi_state *state, *next;
    state = state0;
    next = state1;
    // Operate on 16 symbols (8 bits) at a time
    for (bitcnt = 0; bitcnt < 8; bitcnt++) {
        // Read input symbol pair and compute all possible branch metrics
        mets[0] = mettab[0][symbols[0]] + mettab[0][symbols[1]];
        mets[1] = mettab[0][symbols[0]] + mettab[1][symbols[1]];
        mets[2] = mettab[1][symbols[0]] + mettab[0][symbols[1]];
        mets[3] = mettab[1][symbols[0]] + mettab[1][symbols[1]];
        symbols += 2;

        // These macro calls were generated by genbut.c
        BUTTERFLY(0, 0);
        BUTTERFLY(1, 1);
        BUTTERFLY(2, 3);
        BUTTERFLY(3, 2);
        BUTTERFLY(4, 3);
        BUTTERFLY(5, 2);
        BUTTERFLY(6, 0);
        BUTTERFLY(7, 1);
        BUTTERFLY(8, 0);
        BUTTERFLY(9, 1);
        BUTTERFLY(10, 3);
        BUTTERFLY(11, 2);
        BUTTERFLY(12, 3);
        BUTTERFLY(13, 2);
        BUTTERFLY(14, 0);
        BUTTERFLY(15, 1);
        BUTTERFLY(16, 2);
        BUTTERFLY(17, 3);
        BUTTERFLY(18, 1);
        BUTTERFLY(19, 0);
        BUTTERFLY(20, 1);
        BUTTERFLY(21, 0);
        BUTTERFLY(22, 2);
        BUTTERFLY(23, 3);
        BUTTERFLY(24, 2);
        BUTTERFLY(25, 3);
        BUTTERFLY(26, 1);
        BUTTERFLY(27, 0);
        BUTTERFLY(28, 1);
        BUTTERFLY(29, 0);
        BUTTERFLY(30, 2);
        BUTTERFLY(31, 3);

        // Swap current and next states
        if (bitcnt & 1) {
            state = state0;
            next = state1;
        } else {
            state = state1;
            next = state0;
        }
    }
}

void viterbi_butterfly2(unsigned char* symbols,
                        int mettab[2][256],
                        struct viterbi_state* state0,
                        struct viterbi_state* state1)
{
    // unsigned int bitcnt;
    int mets[4];

    struct viterbi_state *state, *next;
    state = state0;
    next = state1;
    // Operate on 4 symbols (2 bits) at a time

    // Read input symbol pair and compute all possible branch metrics
    mets[0] = mettab[0][symbols[0]] + mettab[0][symbols[1]];
    mets[1] = mettab[0][symbols[0]] + mettab[1][symbols[1]];
    mets[2] = mettab[1][symbols[0]] + mettab[0][symbols[1]];
    mets[3] = mettab[1][symbols[0]] + mettab[1][symbols[1]];

    // These macro calls were generated by genbut.c
    BUTTERFLY(0, 0);
    BUTTERFLY(1, 1);
    BUTTERFLY(2, 3);
    BUTTERFLY(3, 2);
    BUTTERFLY(4, 3);
    BUTTERFLY(5, 2);
    BUTTERFLY(6, 0);
    BUTTERFLY(7, 1);
    BUTTERFLY(8, 0);
    BUTTERFLY(9, 1);
    BUTTERFLY(10, 3);
    BUTTERFLY(11, 2);
    BUTTERFLY(12, 3);
    BUTTERFLY(13, 2);
    BUTTERFLY(14, 0);
    BUTTERFLY(15, 1);
    BUTTERFLY(16, 2);
    BUTTERFLY(17, 3);
    BUTTERFLY(18, 1);
    BUTTERFLY(19, 0);
    BUTTERFLY(20, 1);
    BUTTERFLY(21, 0);
    BUTTERFLY(22, 2);
    BUTTERFLY(23, 3);
    BUTTERFLY(24, 2);
    BUTTERFLY(25, 3);
    BUTTERFLY(26, 1);
    BUTTERFLY(27, 0);
    BUTTERFLY(28, 1);
    BUTTERFLY(29, 0);
    BUTTERFLY(30, 2);
    BUTTERFLY(31, 3);

    state = state1;
    next = state0;

    // Read input symbol pair and compute all possible branch metrics
    mets[0] = mettab[0][symbols[2]] + mettab[0][symbols[3]];
    mets[1] = mettab[0][symbols[2]] + mettab[1][symbols[3]];
    mets[2] = mettab[1][symbols[2]] + mettab[0][symbols[3]];
    mets[3] = mettab[1][symbols[2]] + mettab[1][symbols[3]];

    // These macro calls were generated by genbut.c
    BUTTERFLY(0, 0);
    BUTTERFLY(1, 1);
    BUTTERFLY(2, 3);
    BUTTERFLY(3, 2);
    BUTTERFLY(4, 3);
    BUTTERFLY(5, 2);
    BUTTERFLY(6, 0);
    BUTTERFLY(7, 1);
    BUTTERFLY(8, 0);
    BUTTERFLY(9, 1);
    BUTTERFLY(10, 3);
    BUTTERFLY(11, 2);
    BUTTERFLY(12, 3);
    BUTTERFLY(13, 2);
    BUTTERFLY(14, 0);
    BUTTERFLY(15, 1);
    BUTTERFLY(16, 2);
    BUTTERFLY(17, 3);
    BUTTERFLY(18, 1);
    BUTTERFLY(19, 0);
    BUTTERFLY(20, 1);
    BUTTERFLY(21, 0);
    BUTTERFLY(22, 2);
    BUTTERFLY(23, 3);
    BUTTERFLY(24, 2);
    BUTTERFLY(25, 3);
    BUTTERFLY(26, 1);
    BUTTERFLY(27, 0);
    BUTTERFLY(28, 1);
    BUTTERFLY(29, 0);
    BUTTERFLY(30, 2);
    BUTTERFLY(31, 3);
}

unsigned char viterbi_get_output(struct viterbi_state* state, unsigned char* outbuf)
{
    // Produce output every 8 bits once path memory is full
    //  if((bitcnt % 8) == 5 && bitcnt > 32) {

    //  Find current best path
    unsigned int i, beststate;
    int bestmetric;

    bestmetric = state[0].metric;
    beststate = 0;
    for (i = 1; i < 64; i++)
        if (state[i].metric > bestmetric) {
            bestmetric = state[i].metric;
            beststate = i;
        }
    *outbuf = state[beststate].path >> 24;
    return bestmetric;
}


// printf ("BS = %d\tBSM = %d\tM0 =
// %d\n",beststate,state[beststate].metric,state[0].metric);
// In tail, poison non-zero nodes
// if(bits_out > packet_size-7)
//  for(i=1;i<64;i += 2)
//    state[i].metric = -9999999;

} // namespace fec
} // namespace gr


namespace gr {
namespace fec {

class FEC_API decode_ccsds_27_fb_impl : public decode_ccsds_27_fb
{
private:
    // Viterbi state
    int d_mettab[2][256];
    struct viterbi_state d_state0[64];
    struct viterbi_state d_state1[64];
    unsigned char d_viterbi_in[16];

    int d_count;

public:
    decode_ccsds_27_fb_impl();

    int work(int noutput_items,
             gr_vector_const_void_star& input_items,
             gr_vector_void_star& output_items) override;
};

} /* namespace fec */
}

#include <gnuradio/io_signature.h>

namespace gr {
namespace fec {

decode_ccsds_27_fb::sptr decode_ccsds_27_fb::make()
{
    return gnuradio::make_block_sptr<decode_ccsds_27_fb_impl>();
}

decode_ccsds_27_fb_impl::decode_ccsds_27_fb_impl()
    : sync_decimator("decode_ccsds_27_fb",
                     io_signature::make(1, 1, sizeof(float)),
                     io_signature::make(1, 1, sizeof(char)),
                     2 * 8),
      d_count(0) // Rate 1/2 code, unpacked to packed conversion
{
    float RATE = 0.5;
    float ebn0 = 12.0;
    float esn0 = RATE * pow(10.0, ebn0 / 10.0);

    gen_met(d_mettab, 100, esn0, 0.0, 256);
    viterbi_chunks_init(d_state0);
    viterbi_chunks_init(d_state1);
}

int decode_ccsds_27_fb_impl::work(int noutput_items,
                                  gr_vector_const_void_star& input_items,
                                  gr_vector_void_star& output_items)
{
    const float* in = (const float*)input_items[0];
    unsigned char* out = (unsigned char*)output_items[0];

    for (int i = 0; i < noutput_items * 16; i++) {
        // Translate and clip [-1.0..1.0] to [28..228]
        float sample = in[i] * 100.0 + 128.0;
        if (sample > 255.0)
            sample = 255.0;
        else if (sample < 0.0)
            sample = 0.0;
        unsigned char sym = (unsigned char)(floor(sample));

        d_viterbi_in[d_count % 4] = sym;
        if ((d_count % 4) == 3) {
            // Every fourth symbol, perform butterfly operation
            viterbi_butterfly2(d_viterbi_in, d_mettab, d_state0, d_state1);

            // Every sixteenth symbol, read out a byte
            if (d_count % 16 == 11) {
                // long metric =
                viterbi_get_output(d_state0, out++);
                // printf("%li\n", *(out-1), metric);
            }
        }

        d_count++;
    }

    return noutput_items;
}

} /* namespace fec */
} 